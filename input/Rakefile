C_iFiles		= 150
C_strURL		= "ftp://chuttenh:essingly@ftp.hmpdacc.org/WholeMetagenomic/00-PreProduction/04-Annotation/"
C_strMock		= "MockAssemblies/"
C_strMalign		= "MockReadBased/"
C_strRTG		= "RTG_102_samples/"
C_strSynth		= "SyntheticMRCommunities/"
C_strBlast		= "reference_vs_prediction_blasts/"
C_strJCVI		= "annotation_rules.combined.out"
C_strMBlastX	= C_strSynth + "mblastx/"

def encurl( strPath, strOut = nil )

	strRet = "curl --ftp-ssl -k " + C_strURL + strPath
	if( strOut )
		strRet += " -o " + strOut; end
	return strRet; end

########## S102 sample data

file "dirs.txt" => [] do |pT|
	sh encurl( C_strRTG, pT.name )
end

file "files.txt" => ["dirs.txt"] do |pT|
	File.open( pT.name, "w" ) do |fileOut|
		IO.foreach( pT.prerequisites[0] ) do |strLine|
			if( strLine.strip !~ /^\s*\S+\s+\d+\s+\d+\s+\S+\s+\d+\s+\S+\s+\d+\s+\S+\s+(.+)$/ )
				next; end
			strDir = $1
			strCmd = encurl( C_strRTG + strDir + "/" )
			strFiles = `#{strCmd}`
			strFiles.each_line do |strFile|
				if( strFile.strip !~ /^\s*\S+\s+\d+\s+\d+\s+\S+\s+\d+\s+\S+\s+\d+\s+\S+\s+(.+)$/ )
					next; end
				fileOut.puts( strDir + "/" + $1 ); end; end; end
end

task :s102 => ["files.txt"] do |pT|
	IO.foreach( pT.prerequisites[0] ) do |strLine|
		if( $. > C_iFiles )
			break; end
		strDir, strFile = strLine.strip.split( /\// )
		strOut = strDir + "_" + strFile
		if( !File.exists?( strOut ) )
			sh encurl( C_strRTG + strDir + "/" + strFile, strOut ); end; end
end

########## mocks

file "mock.txt" => [] do |pT|
	sh encurl( C_strMock + C_strBlast, pT.name )
end

task :mock => ["mock.txt"] do |pT|
	IO.foreach( pT.prerequisites[0] ) do |strLine|
		if( strLine.strip !~ /^\s*\S+\s+\d+\s+\d+\s+\S+\s+\d+\s+\S+\s+\d+\s+\S+\s+(.+)$/ )
			next; end
		strFile = $1
		if( !File.exists?( strFile ) )
			sh encurl( [C_strMock + C_strBlast, strFile].join( "/" ),
				strFile ); end; end
end

["jcvi_annotation_mock_even.tab", "jcvi_annotation_mock_stg.tab"].each do |strJCVI|
	strJCVI =~ /^([^_]+).*?([^_]+)\.\S+/
	strFile = "mock" + $2 + "_soap_" + $1 + ".jcvi"
	file strFile => [] do |pT|
		strJCVI =~ /^(.+)\.\S+$/
		sh encurl( C_strMock + [$1, C_strJCVI].join( "/" ), pT.name )
	end
	task :mock => strFile
end

file "mockstg_soap_jgi.jgi" => [] do |pT|
	"jgi_annotation_mock_stg.tab" =~ /^(.+)\.\S+$/
	sh encurl( C_strMock + [$1, $1 + ".gz"].join( "/" ) ) +
		" | gunzip | sort -k2 > " + pT.name
end
task :mock => "mockstg_soap_jgi.jgi"

file "mock_community_mapx_alignments.tar.gz" => [] do |pT|
	sh encurl( C_strMalign + pT.name, pT.name )
end

file "mock_community_mapx_alignments.txt" =>
	["mock_community_mapx_alignments.tar.gz"] do |pT|
	sh "tar -xzf " + pT.prerequisites[0]
	fFirst = true
	Dir.glob( "mapx_alignments/*" ).each do |strFile|
		sh "gunzip -c " + strFile + " >" + ( fFirst ? "" : ">" ) + " " +
			pT.name
		fFirst = false; end
end
#Commented out since this isn't quite right - needs to sep. even/staggered
#task :mock => "mock_community_mapx_alignments.txt"

########## Synthetic communities

def files( pT, strBase )

	IO.foreach( pT.prerequisites[0] ) do |strLine|
		if( strLine.strip !~ /^\s*\S+\s+\d+\s+\d+\s+\S+\s+\d+\s+\S+\s+\d+\s+\S+\s+(.+)$/ )
			next; end
		strFile = $1
		if( !File.exists?( strFile ) )
			sh encurl( strBase + "/" + strFile, strFile ); end; end; end

file "synth.txt" => [] do |pT|
	sh encurl( C_strSynth, pT.name )
end

task :synth => ["synth.txt"] do |pT|
	files( pT, C_strSynth )
end

file "mblastx.txt" => [] do |pT|
	sh encurl( C_strMBlastX, pT.name )
end

task :mblastx => ["mblastx.txt"] do |pT|
	files( pT, C_strMBlastX )
end

##########

task :default => [:s102, :mock, :synth, :mblastx] do |pT|
end
