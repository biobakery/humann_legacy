import glob
import os
import re
import subprocess
import sys

c_iBases			= 10**9
c_iReadLength		= 100
c_iReads			= int(10**8 / c_iReadLength)
c_iPairs			= int(c_iReads / 2)
c_iHC				= 100
c_iQ				= 5

c_fFrozen			= True
c_strDirOutput		= "output/"
c_strSeqBase		= "s_1_1_export"
c_strFA				= ".fa"
c_strQual			= ".qual"
c_strInputSeqFA		= c_strDirOutput + c_strSeqBase + c_strFA
c_strInputSeqQUAL	= c_strInputSeqFA + c_strQual
c_strDirSource		= "../src/"
c_strDirData		= "../data/"
c_strInputKOC		= c_strDirData + "koc"
c_strInputModuleC	= c_strDirData + "modulec"

c_strTARBZ			= ".tar.bz2"
c_strTXT			= ".txt"
c_strGenome			= ".genome"
c_strShred			= ".shred"
c_strFASTQ			= ".fastq"
c_strDAT			= ".dat"
c_strLIST			= ".list"
c_strCov			= "_04a"
c_strAbd			= "_04b"
c_strKOs			= "_01"
c_strOrganisms		= "organisms_"
c_strPathway		= "_pathway"
c_strModule			= "_module"
c_astrOrganisms		= glob.glob( c_strOrganisms + "*.txt" )
c_strMAQBase		= "maq-0.7.1"
c_strFileOrgsHCTXT	= c_strOrganisms + "hc" + c_strTXT
c_strFileGenome		= c_strDirOutput + "genome"
c_strFileMAQTARBZ	= c_strMAQBase + c_strTARBZ
c_strFileSeqFASTQ	= c_strDirOutput + c_strSeqBase + c_strFASTQ
c_strFileModelDAT	= c_strDirOutput + c_strSeqBase + c_strDAT
c_strProgMixer		= "./mixer.py"
c_strProgQ2FQ		= "./qual2fastq.pl"
c_strProgTrimFQ		= "./trim_fastq.py"
c_strProgFQ2FA		= "./fastq2fasta.py"
c_strProgTrimmer	= "./TrimBWAstyle.pl"
c_strProgCov		= "./orgs2cov.py"
c_strProgAbd		= "./orgs2abd.py"
c_strProgKOs		= "./orgs2kos.py"
c_strProgModules	= "./modules.py"
c_strProgGenome2Orgs	= "./genomes2orgs.py"
c_strProgMAQ		= "./" + c_strMAQBase + "/maq"
c_astrTypes			= ["even", "stg"]
c_strURLKEGG		= "ftp://ftp.genome.jp/pub/kegg/genes/organisms/"
c_strURLMAQ			= "http://downloads.sourceforge.net/project/maq/maq/0.7.1/"
c_strMock			= "mock_"

pE = Environment( )
if c_fFrozen:
	def decider( dependency, target, prev_ni ):
		strFrom, strTo = (s.get_abspath( ) for s in (dependency, target))
		if not os.path.exists( strFrom ):
			return True
		if ( not os.path.getsize( strFrom ) ) or \
			( os.path.exists( strTo ) and ( not os.path.getsize( strTo ) ) ):
			return False
		
		dep_csig = dependency.get_csig( )
		if ( "csig" not in dir( prev_ni ) ) or \
			( not os.path.exists( target.get_abspath( ) ) ):
			return True
		return ( dep_csig != prev_ni.csig )
	pE.Decider( decider )
else:
	pE.Decider( "MD5-timestamp" )
pE.Dir( c_strDirOutput )

#===============================================================================
# Utility methods
#===============================================================================

def sh( strCmd ):

	sys.stdout.write( "%s\n" % strCmd )
	hashEnv = os.environ
	strPP = hashEnv.get( "PYTHONPATH" )
	hashEnv["PYTHONPATH"] = ( ( strPP + ":" ) if strPP else "" ) + c_strDirSource
	return subprocess.call( strCmd, stdout = sys.stdout, shell = True )

def ts( astrTargets, astrSources ):
	
	return (str(astrTargets[0]), [pF.get_abspath( ) for pF in astrSources]) 

def enstrip( strTarget, strSuffix = None ):

	strRet = strTarget.replace( c_strDirOutput, "" )
	return ( strRet.replace( strSuffix, "" ) if strSuffix else strRet )

def encurl( strURL, strTarget, strSuffix = None ):

	return ( "curl " + strURL + enstrip( strTarget, strSuffix ) ) 

#===============================================================================
# KEGG reference genome downloads
#===============================================================================

def funcOrgTXT( target, source, env ):
	'''
	Download directory listing for one KEGG organism to allow determination of
	genome file name.
	'''
	strT, astrSs = ts( target, source )
	return sh( encurl( c_strURLKEGG, strT, c_strTXT ) + "/ > " + strT )

def funcOrgFile( target, source, env ):
	'''
	Download a specific file from KEGG.
	'''
	strT, astrSs = ts( target, source )
	pMatch = re.search( '([a-z]{3})_', strT )
	return sh( encurl( c_strURLKEGG + pMatch.group( 1 ) + "/", strT ) + " > " + strT )

def funcOrgGenome( target, source, env ):
	'''
	Scan a downloaded KEGG directory file listing to find and download a
	*.genome file.
	'''
	strT, astrSs = ts( target, source )
	strDir = astrSs[0]
	for strLine in open( strDir ):
		pMatch = re.search( '(\S+\.genome)', strLine )
		if pMatch:
			return sh( encurl( c_strURLKEGG, strT, c_strGenome ) + "/" + pMatch.group( 1 ) + " > " + strT )
	return 1

#===============================================================================
# Illumina error model using MAQ
#===============================================================================

def funcDownloadMAQ( target, source, env ):

	strT, astrSs = ts( target, source )
	return sh( "curl -LO " + c_strURLMAQ + strT )
pE.Command( c_strFileMAQTARBZ, None, funcDownloadMAQ )

def funcUntarMAQ( target, source, env ):
	
	strT, astrSs = ts( target, source )
	strTarball = astrSs[0]
	return ( sh( "tar -xjf " + strTarball ) or
		sh( "cd " + enstrip( strTarball, c_strTARBZ ) + " && ./configure && make" ) )
pE.Command( c_strProgMAQ, [c_strFileMAQTARBZ], funcUntarMAQ )

def funcQ2FQ( target, source, env ):
	
	strT, astrSs = ts( target, source )
	astrQ2FQ, progTrim = astrSs[:3], astrSs[-1]
	return sh( " ".join( astrQ2FQ + ["|", progTrim, str(c_iReadLength), ">", strT] ) )
pE.Command( c_strFileSeqFASTQ, [c_strProgQ2FQ, c_strInputSeqFA, c_strInputSeqQUAL,
	c_strProgTrimFQ], funcQ2FQ )

def funcMAQTrain( target, source, env ):
	
	strT, astrSs = ts( target, source )
	strMAQ, strFASTQ = astrSs
	return sh( " ".join( (strMAQ, "simutrain", strT, strFASTQ) ) )
pE.Command( c_strFileModelDAT, [c_strProgMAQ, c_strFileSeqFASTQ], funcMAQTrain )

def funcMAQShred( target, source, env ):

	astrTs, astrSs = ([str(pF) for pF in target], [pF.get_abspath( ) for pF in source])
	strMAQ, strFASTA, strModel = astrSs
	sh( " ".join( (strMAQ, "simulate", "-1", str(c_iReadLength), "-2", str(c_iReadLength),
		"-N", str(c_iPairs), astrTs[0], astrTs[1], strFASTA, strModel) ) )

def funcJoinPE( target, source, env ):
	
	strT, astrSs = ts( target, source )
	strProgTrim, strProgJoin, strOne, strTwo = astrSs
	return sh( "cat " + " ".join( (strOne, strTwo) ) + " | " + strProgTrim + " -q " + str(c_iQ) +
		" | " + strProgJoin + " > " + strT )

#===============================================================================
# High complexity community definition (randomized from KEGG)
#===============================================================================

def funcKEGGGenomes( target, source, env ):

	strT, astrSs = ts( target, source )
	return sh( encurl( c_strURLKEGG + "../", strT ) + " > " + strT )
pE.Command( c_strFileGenome, None, funcKEGGGenomes )

def funcOrgsHC( target, source, env ):

	strT, astrSs = ts( target, source )
	return sh( " ".join( (astrSs[0], str(c_iHC), "<", astrSs[1], ">", strT) ) )
pE.Command( c_strFileOrgsHCTXT, [c_strProgGenome2Orgs, c_strFileGenome], funcOrgsHC )

#===============================================================================
# Scan organism definition file and build download/shred rules
#===============================================================================

for strOrganisms in c_astrOrganisms:
	astrShredded = []
	astrPathways = []
	for strLine in open( strOrganisms ):
		strLine = strLine.strip( )
		if strLine[0] == "#":
			continue

		strOrg, strAmt = strLine.split( "\t" )
		strTXT, strGenome, strShred = (( c_strDirOutput + strOrg + strCur ) for strCur in
			(c_strTXT, c_strGenome, c_strShred))
		pE.Command( strTXT, None, funcOrgTXT )
		pE.Command( strGenome, [strTXT], funcOrgGenome )
		strOne, strTwo = (( c_strDirOutput + strOrg + strCur ) for strCur in (".1", ".2"))
		pE.Command( [strOne, strTwo], [c_strProgMAQ, strGenome, c_strFileModelDAT], funcMAQShred )
		pE.Command( strShred, [c_strProgTrimmer, c_strProgFQ2FA, strOne, strTwo], funcJoinPE )
		astrShredded.append( strShred )

		def funcOrgModules( target, source, env, strOrg = strOrg ):
			strT, astrSs = ts( target, source )
			strProg, strKO, strModuleC = astrSs
			return sh( " ".join( (strProg, strOrg, strKO, "<", strModuleC, ">", strT) ) )

		strPathway = c_strDirOutput + strOrg + c_strPathway + c_strLIST
		strModule = strPathway.replace( c_strPathway, c_strModule )
		astrPathways += [strPathway, strModule]
		pE.Command( strModule, [c_strProgModules, c_strInputKOC, c_strInputModuleC], funcOrgModules )
		if not c_fFrozen:
			pE.Command( strPathway, None, funcOrgFile )

# Finally build rules for each type of mock community, even and staggered
	for i in range( len( c_astrTypes ) ):
		def funcMix( target, source, env, iMix = i ):
		
			strT, astrSs = ts( target, source )
			strMixer, strOrgs, astrShredded = astrSs[0], astrSs[1], astrSs[2:]
			return sh( " ".join( [strMixer, str(c_iReads), str(iMix)] + astrShredded ) + " < " +
				strOrgs + " > " + strT )
		
# Build the mock community sequences themselves
		strMock = c_strDirOutput + strOrganisms.replace( c_strOrganisms, "%s%s_" %
			tuple((c_strMock, c_astrTypes[i])) )
		pE.Command( strMock, [c_strProgMixer, strOrganisms] + astrShredded, funcMix )
		if not c_fFrozen:
			Default( strMock )

#===============================================================================
# Gold standards
#===============================================================================

# Gold standard KOs
		def funcKOs( target, source, env, iMix = i ):

			strT, astrSs = ts( target, source )
			strProg, strOrganisms, strKOC = astrSs
			return sh( " ".join( [strProg, str(iMix), strKOC, "<", strOrganisms, ">", strT] ) )

		strKOs = strMock.replace( c_strTXT, c_strKOs + c_strTXT )
		pE.Command( strKOs, [c_strProgKOs, strOrganisms, c_strInputKOC], funcKOs )
		Default( strKOs )

# Gold standard KEGG pathways
		def funcAbdCov( target, source, env, iMix = i ):

			strT, astrSs = ts( target, source )
			strProg, strOrganisms, astrPathways = astrSs[0], astrSs[1], astrSs[2:]
			return sh( " ".join( [strProg, str(iMix)] + astrPathways +
				["<", strOrganisms, ">", strT] ) )

		strCov = strMock.replace( c_strTXT, c_strCov + c_strTXT )
		pE.Command( strCov, [c_strProgCov, strOrganisms] + astrPathways, funcAbdCov )
		Default( strCov )
		strAbd = strCov.replace( c_strCov, c_strAbd )
		pE.Command( strAbd, [c_strProgAbd, strOrganisms] + astrPathways, funcAbdCov )
		Default( strAbd )
