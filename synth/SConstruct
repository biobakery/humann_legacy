import os
import re
import subprocess
import sys

#===============================================================================
# Configurable parameters
#===============================================================================
# True if current HC/LC communities and sequences should be left unchanged
c_fFrozen				= True
# Total number of target bases per organism
c_iBases				= 10**8
# Simulated read length (should match training data for MAQ error model)
c_iReadLength			= 100
# Number of organisms in high complexity community (randomly selected)
c_iHC					= 100
# Minimum score for quality trimming
c_iQ					= 5
# Minimum length for quality trimming
c_iLength				= int(round( c_iReadLength * 0.6 ))
# Synthetic community types to generate
c_astrTypes				= ["even", "stg"]
c_iReads				= int(c_iBases / c_iReadLength)
c_iPairs				= int(c_iReads / 2)

#===============================================================================
# Prefixes, suffixes, and other simple constants
#===============================================================================
c_strMock				= "mock_"
c_strOrganisms			= "organisms_"
c_strPathway			= "_pathway"
c_strModule				= "_module"
c_strFASTA				= ".fasta"
c_strFA					= ".fa"
c_strQual				= ".qual"
c_strTARBZ				= ".tar.bz2"
c_strTXT				= ".txt"
c_strGenome				= ".genome"
c_strShred				= ".shred"
c_strFASTQ				= ".fastq"
c_strDAT				= ".dat"
c_strLIST				= ".list"
#===============================================================================
# Type markers for HUMAnN output files
#===============================================================================
c_strCov				= "_04a"
c_strAbd				= "_04b"
c_strKOs				= "_01"

#===============================================================================
# Directories
#===============================================================================
c_strDirInput			= "input/"
c_strDirOutput			= "output/"
c_strDirSrc				= "./src/"
c_strDirSource			= "../src/"
c_strDirData			= "../data/"

#===============================================================================
# Manually provided input files - includes .fa/.qual pair for MAQ model training
#===============================================================================
c_strSeqBase			= "s_1_1_export"
c_strInputSeqFA			= c_strDirInput + c_strSeqBase + c_strFA
c_strInputSeqQUAL		= c_strInputSeqFA + c_strQual
# Total set of KOs included in seq. DB for gold standard (optional)
c_strInputKOs			= "kos"
# koc, modulep, and pathwayc must be generated by HUMAnN before synthetic communities
c_strInputKOC			= c_strDirData + "koc"
c_strInputModuleP		= c_strDirData + "modulep"
c_strInputPathwayC		= c_strDirData + "pathwayc"
c_afileOrganisms		= Glob( c_strOrganisms + "*.txt" )

#===============================================================================
# Generated output files
#===============================================================================
c_strFileOrgsHCTXT		= c_strOrganisms + "hc" + c_strTXT
c_strFileGenome			= c_strDirOutput + "genome"
c_strFileSeqFASTQ		= c_strDirOutput + c_strSeqBase + c_strFASTQ
c_strFileModelDAT		= c_strDirOutput + c_strSeqBase + c_strDAT

#===============================================================================
# Scripts for synthetic community generation
#===============================================================================
sd = lambda s: c_strDirSrc + s
c_strProgMixer			= sd( "mixer.py" )
c_strProgQ2FQ			= sd( "qual2fastq.pl" )
c_strProgTrimFQ			= sd( "trim_fastq.py" )
c_strProgFQ2FA			= sd( "fastq2fasta.py" )
c_strProgTrimmer		= sd( "TrimBWAstyle.pl" )
c_strProgCov			= sd( "orgs2cov.py" )
c_strProgAbd			= sd( "orgs2abd.py" )
c_strProgKOs			= sd( "orgs2kos.py" )
c_strProgModules		= sd( "modules.py" )
c_strProgGenome2Orgs	= sd( "genomes2orgs.py" )

#===============================================================================
# MAQ
#===============================================================================
c_strURLMAQ				= "http://downloads.sourceforge.net/project/maq/maq/0.7.1/"
c_strMAQBase			= "maq-0.7.1"
c_strFileMAQTARBZ		= c_strMAQBase + c_strTARBZ
c_strProgMAQ			= "./" + c_strMAQBase + "/maq"

c_strURLKEGG			= "ftp://ftp.genome.jp/pub/kegg/genes/organisms/"

if c_fFrozen:
	def decider( dependency, target, prev_ni ):
		strFrom, strTo = (s.get_abspath( ) for s in (dependency, target))
		if not os.path.exists( strFrom ):
			return True
		if ( not os.path.getsize( strFrom ) ) or \
			( os.path.exists( strTo ) and ( not os.path.getsize( strTo ) ) ):
			return False
		
		dep_csig = dependency.get_csig( )
		if ( "csig" not in dir( prev_ni ) ) or \
			( not os.path.exists( target.get_abspath( ) ) ):
			return True
		return ( dep_csig != prev_ni.csig )
	Decider( decider )
else:
	Decider( "MD5-timestamp" )
Dir( c_strDirOutput )

#===============================================================================
# Utility methods
#===============================================================================

def sh( strCmd ):

	sys.stdout.write( "%s\n" % strCmd )
	hashEnv = os.environ
	strPP = hashEnv.get( "PYTHONPATH" )
	hashEnv["PYTHONPATH"] = ( ( strPP + ":" ) if strPP else "" ) + c_strDirSource
	return subprocess.call( strCmd, stdout = sys.stdout, shell = True )

def ts( astrTargets, astrSources ):
	
	return (str(astrTargets[0]), [pF.get_abspath( ) for pF in astrSources]) 

def enstrip( strTarget, strSuffix = None ):

	strRet = strTarget.replace( c_strDirOutput, "" )
	return ( strRet.replace( strSuffix, "" ) if strSuffix else strRet )

def encurl( strURL, strTarget, strSuffix = None ):

	return ( "curl " + strURL + enstrip( strTarget, strSuffix ) ) 

#===============================================================================
# KEGG reference genome downloads
#===============================================================================

def funcOrgTXT( target, source, env ):
	"""
	Download directory listing for one KEGG organism to allow determination of
	genome file name.
	"""
	strT, astrSs = ts( target, source )
	return sh( encurl( c_strURLKEGG, strT, c_strTXT ) + "/ > " + strT )

def funcOrgFile( target, source, env ):
	"""
	Download a specific file from KEGG.
	"""
	strT, astrSs = ts( target, source )
	pMatch = re.search( '([a-z]{3})_', strT )
	return sh( encurl( c_strURLKEGG + pMatch.group( 1 ) + "/", strT ) + " > " + strT )

def funcOrgGenome( target, source, env ):
	"""
	Scan a downloaded KEGG directory file listing to find and download a
	*.genome file.
	"""
	strT, astrSs = ts( target, source )
	strDir = astrSs[0]
	for strLine in open( strDir ):
		pMatch = re.search( '(\S+\.genome)', strLine )
		if pMatch:
			return sh( encurl( c_strURLKEGG, strT, c_strGenome ) + "/" + pMatch.group( 1 ) + " > " + strT )
	return 1

#===============================================================================
# Illumina error model using MAQ
#===============================================================================

if not os.path.isfile( c_strFileModelDAT ):
	def funcDownloadMAQ( target, source, env ):
	
		strT, astrSs = ts( target, source )
		return sh( "curl -LO " + c_strURLMAQ + strT )
	Command( c_strFileMAQTARBZ, None, funcDownloadMAQ )
	
	def funcUntarMAQ( target, source, env ):
		
		strT, astrSs = ts( target, source )
		strTarball = astrSs[0]
		return ( sh( "tar -xjf " + strTarball ) or
			sh( "cd " + enstrip( strTarball, c_strTARBZ ) + " && ./configure && make" ) )
	Command( c_strProgMAQ, [c_strFileMAQTARBZ], funcUntarMAQ )
	
	def funcQ2FQ( target, source, env ):
		
		strT, astrSs = ts( target, source )
		astrQ2FQ, progTrim = astrSs[:3], astrSs[-1]
		return sh( " ".join( astrQ2FQ + ["|", progTrim, str(c_iReadLength), ">", strT] ) )
	Command( c_strFileSeqFASTQ, [c_strProgQ2FQ, c_strInputSeqFA, c_strInputSeqQUAL,
		c_strProgTrimFQ], funcQ2FQ )
	
	def funcMAQTrain( target, source, env ):
		
		strT, astrSs = ts( target, source )
		strMAQ, strFASTQ = astrSs
		return sh( " ".join( (strMAQ, "simutrain", strT, strFASTQ) ) )
	Command( c_strFileModelDAT, [c_strProgMAQ, c_strFileSeqFASTQ], funcMAQTrain )

def funcMAQShred( target, source, env ):

	astrTs, astrSs = ([str(pF) for pF in target], [pF.get_abspath( ) for pF in source])
	strMAQ, strFASTA, strModel = astrSs
	sh( " ".join( (strMAQ, "simulate", "-1", str(c_iReadLength), "-2", str(c_iReadLength),
		"-N", str(c_iPairs), astrTs[0], astrTs[1], strFASTA, strModel) ) )

def funcJoinPE( target, source, env ):
	
	strT, astrSs = ts( target, source )
	strProgTrim, strProgJoin, strOne, strTwo = astrSs
	return sh( "cat " + " ".join( (strOne, strTwo) ) + " | " + strProgTrim + " -q " + str(c_iQ) +
		" | " + strProgJoin + " > " + strT )

#===============================================================================
# High complexity community definition (randomized from KEGG)
#===============================================================================

def funcKEGGGenomes( target, source, env ):

	strT, astrSs = ts( target, source )
	return sh( encurl( c_strURLKEGG + "../", strT ) + " > " + strT )
Command( c_strFileGenome, None, funcKEGGGenomes )

def funcOrgsHC( target, source, env ):

	strT, astrSs = ts( target, source )
	return sh( " ".join( (astrSs[0], str(c_iHC), "<", astrSs[1], ">", strT) ) )
if not c_fFrozen:
	Command( c_strFileOrgsHCTXT, [c_strProgGenome2Orgs, c_strFileGenome], funcOrgsHC )

#===============================================================================
# Scan organism definition file and build download/shred rules
#===============================================================================

for strOrganisms in (f.get_abspath( ) for f in c_afileOrganisms):
	astrShredded = []
	astrPathways = []
	for strLine in open( strOrganisms ):
		strLine = strLine.strip( )
		if strLine[0] == "#":
			continue

		strOrg, strAmt = strLine.split( "\t" )
		strTXT, strGenome, strShred = (( c_strDirOutput + strOrg + strCur ) for strCur in
			(c_strTXT, c_strGenome, c_strShred))
		Command( strTXT, None, funcOrgTXT )
		Command( strGenome, [strTXT], funcOrgGenome )
		strOne, strTwo = (( c_strDirOutput + strOrg + strCur ) for strCur in (".1", ".2"))
		Command( [strOne, strTwo], [c_strProgMAQ, strGenome, c_strFileModelDAT], funcMAQShred )
		Command( strShred, [c_strProgTrimmer, c_strProgFQ2FA, strOne, strTwo], funcJoinPE )
		astrShredded.append( strShred )

		def funcOrgModules( target, source, env, strOrg = strOrg ):
			strT, astrSs = ts( target, source )
			strProg, strKO, strModuleC = astrSs
			return sh( " ".join( (strProg, strOrg, strKO, "<", strModuleC, ">", strT) ) )

		strPathway = c_strDirOutput + strOrg + c_strPathway + c_strLIST
		strModule = strPathway.replace( c_strPathway, c_strModule )
		astrPathways += [strPathway, strModule]
		Command( strModule, [c_strProgModules, c_strInputKOC, c_strInputModuleP], funcOrgModules )
		Command( strPathway, None, funcOrgFile )

# Finally build rules for each type of mock community, even and staggered
	for i in range( len( c_astrTypes ) ):
		def funcMix( target, source, env, iMix = i ):
		
			strT, astrSs = ts( target, source )
			strMixer, strOrgs, astrShredded = astrSs[0], astrSs[1], astrSs[2:]
			return sh( " ".join( [strMixer, str(c_iReads), str(iMix)] + astrShredded ) + " < " +
				strOrgs + " > " + strT )
		
# Build the mock community sequences themselves
		strMock = c_strDirOutput + os.path.basename( strOrganisms ).replace( c_strOrganisms, "%s%s_" %
			tuple((c_strMock, c_astrTypes[i])) ).replace( c_strTXT, c_strFASTA )
		Command( strMock, [c_strProgMixer, strOrganisms] + astrShredded, funcMix )
		if not c_fFrozen:
			Default( strMock )

#===============================================================================
# Gold standards
#===============================================================================

# Gold standard KOs
		def funcKOs( target, source, env, iMix = i ):

			strT, astrSs = ts( target, source )
			strProg, strOrganisms, strKOC, strKOs = astrSs + ( [""] * ( 4 - len( astrSs ) ) )
			return sh( " ".join( [strProg, str(iMix), strKOC, strKOs, "<", strOrganisms, ">", strT] ) )

		strKOs = strMock.replace( c_strFASTA, c_strKOs + c_strTXT )
		Command( strKOs, [c_strProgKOs, strOrganisms, c_strInputKOC] +
			( [c_strInputKOs] if os.path.isfile( c_strInputKOs ) else [] ), funcKOs )
		Default( strKOs )

# Gold standard KEGG pathways
		def funcAbdCov( target, source, env, iMix = i ):

			strT, astrSs = ts( target, source )
			strProg, strOrganisms, astrPathways = astrSs[0], astrSs[1], astrSs[2:]
			return sh( " ".join( [strProg, str(iMix)] + astrPathways +
				["<", strOrganisms, ">", strT] ) )

		strCov = strMock.replace( c_strFASTA, c_strCov + c_strTXT )
		Command( strCov, [c_strProgCov, strOrganisms, c_strInputPathwayC] + astrPathways,
			funcAbdCov )
		Default( strCov )
		strAbd = strCov.replace( c_strCov, c_strAbd )
		Command( strAbd, [c_strProgAbd, strOrganisms, c_strInputPathwayC] + astrPathways,
			funcAbdCov )
		Default( strAbd )
